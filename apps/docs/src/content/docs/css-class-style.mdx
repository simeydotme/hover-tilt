---
title: CSS Class / Style
description: Styling guidance for the Hover Tilt container and glare overlay.
---

import { Tabs, TabItem, Code } from '@astrojs/starlight/components';
import RadiusSvelte from '../../chunks/class-style/RadiusSvelte.astro';
import RadiusWebC from '../../chunks/class-style/RadiusWebC.astro';

export const svelteExample = String.raw`
<HoverTilt class="rounded-3xl">
  <div class="rounded-3xl"> <!-- this radius matches the radius above -->
    Your content here
  </div>
</HoverTilt>
`;

export const webComponentMarkup = String.raw`
<hover-tilt class="tilt-card">
  <div class="content-card">
    Your content here
  </div>
</hover-tilt>
`;

export const webComponentStyles = String.raw`
.tilt-card::part(container),   /* the shadow container */
.content-card {                /* the content */
  border-radius: 24px;
}
`;

`HoverTilt` wraps your content with two elements:

- A **`container`** element that handles perspective and listens for pointer events.
- An inner **`tilt`** element that applies transforms and contains the glare effect.

## Styling the internals


<Tabs syncKey="api">
  <TabItem label="Svelte">
```txt
<div class="hover-tilt-container"> 
  └── <div class="hover-tilt">
        └── slotted content
```

In Svelte, you can style the component's internal elements via `class` on the `<HoverTilt>`, and then build a css declaration.


</TabItem>
  <TabItem label="Web Component">
```txt
<hover-tilt>
  ├── #shadow-root
  │     └── <div part="container">
  │           └── <div part="tilt">
  │                 └── <slot />
  └── slotted content (Light DOM)
```

So to style the web-component's internal elements,
[use `::part(container)` and `::part(tilt)` CSS selectors](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Selectors/::part) to style the shadow DOM elements.

#### `::part(container)` 

> wraps the tilt effect. 

_Generally you don't want to modify the style of this,
except for things like `perspective` or `perspective-origin`._

#### `::part(tilt)` 

> is the animated layer that holds the glare pseudo-element. 

_`::part(tilt)` inherits the `border-radius` of the container, so you can 
either apply a radius to the `::part(container)` or the `::part(tilt)` 
(see below for more details)._


</TabItem>
</Tabs>

### Glare & `border-radius`

If you are applying a `border-radius` to the content, you may notice that the 
glare overflows the radius. This is because the glare is a pseudo-element 
that is applied to the `::before` pseudo-element of the `tilt` element.

So you typically want the container to match border radii (or any clipping) on 
that inner layer to avoid the glare spilling past rounded corners. (see example below)

<br /> <br />

<Tabs syncKey="api">

  <TabItem label="Svelte">
    The Svelte component exposes a `class` prop on the container. And the 
    `tilt` and `::before` elements both inherit the `border-radius` of the container.

    So as long as we apply the same `border-radius` to the container as the content, 
    the glare will not overflow the radius.

    <Code lang="svelte" title="Card.svelte" code={svelteExample} />

    <RadiusSvelte />

  </TabItem>

  <TabItem label="Web Component">
    The custom element renders inside Shadow DOM, so classes on `<hover-tilt>` 
    only affect the host and not the internal container/tilt nodes. 
    
    Use the [CSS `::part()` selector](https://developer.mozilla.org/en-US/docs/Web/CSS/::part) to 
    reach those internal elements:

    <Code lang="html" title="index.html" code={webComponentMarkup} />
    <Code lang="css" title="styles.css" code={webComponentStyles} />

    <RadiusWebC />

  </TabItem>

</Tabs>


---

### Overflow on container

Because the tilt element is inside of the container, if you apply an `overflow: hidden`
to the container, the tilt effect will be cut off and look broken.

If you need to clip content to the card area, then apply an `overflow: hidden` 
to the tilt element, or more preferably to the slotted content.